<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion-Reactive Fluid Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            pointer-events: none;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .controls.hidden {
            transform: translateX(-120%);
            opacity: 0;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            transition: transform 0.2s ease;
        }
        
        input[type="color"]:hover {
            transform: scale(1.05);
        }
        
        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 15px;
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(20, 20, 30, 0.9);
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }
        
        .status.error {
            background: rgba(220, 20, 20, 0.9);
        }
        
        #toggleUI {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #toggleUI.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="motionCanvas"></canvas>
    <canvas id="fluidCanvas"></canvas>
    
    <button id="toggleUI" onclick="toggleUI()">Show Controls</button>
    
    <div class="controls" id="controls">
        <h3 style="color: #fff; margin-bottom: 20px;">Fluid Controls</h3>
        
        <div class="control-group">
            <label for="fluidColor">Fluid Color</label>
            <input type="color" id="fluidColor" value="#4a90e2">
        </div>
        
        <div class="control-group">
            <label for="backgroundColor">Background Color</label>
            <input type="color" id="backgroundColor" value="#0a0a0a">
        </div>
        
        <div class="control-group">
            <label for="sensitivity">Motion Sensitivity</label>
            <input type="range" id="sensitivity" min="10" max="100" value="30">
        </div>
        
        <div class="control-group">
            <label for="fluidDensity">Fluid Density</label>
            <input type="range" id="fluidDensity" min="1" max="10" value="5">
        </div>
        
        <div class="control-group">
            <label for="flowSpeed">Flow Speed</label>
            <input type="range" id="flowSpeed" min="0.1" max="5" step="0.1" value="2">
        </div>
        
        <div class="button-group">
            <button onclick="toggleMirror()">Mirror: OFF</button>
            <button onclick="toggleFullscreen()">Fullscreen</button>
            <button onclick="toggleUI()">Hide UI</button>
            <button onclick="resetSimulation()">Reset</button>
        </div>
    </div>
    
    <div class="status" id="status">Initializing webcam...</div>
    
    <script>
        const video = document.getElementById('webcam');
        const motionCanvas = document.getElementById('motionCanvas');
        const fluidCanvas = document.getElementById('fluidCanvas');
        const motionCtx = motionCanvas.getContext('2d');
        const fluidCtx = fluidCanvas.getContext('2d');
        const controls = document.getElementById('controls');
        const toggleBtn = document.getElementById('toggleUI');
        const status = document.getElementById('status');
        
        let mirrored = false;
        let uiHidden = false;
        let previousFrame = null;
        let motionData = [];
        let particles = [];
        let gridSize = 20;
        let cols, rows;
        let flowField = [];
        
        // Settings
        let settings = {
            fluidColor: '#4a90e2',
            backgroundColor: '#0a0a0a',
            sensitivity: 30,
            fluidDensity: 5,
            flowSpeed: 2
        };
        
        // Resize canvases
        function resizeCanvases() {
            motionCanvas.width = window.innerWidth;
            motionCanvas.height = window.innerHeight;
            fluidCanvas.width = window.innerWidth;
            fluidCanvas.height = window.innerHeight;
            
            cols = Math.ceil(window.innerWidth / gridSize);
            rows = Math.ceil(window.innerHeight / gridSize);
            
            initializeFlowField();
            initializeParticles();
        }
        
        // Initialize flow field
        function initializeFlowField() {
            flowField = [];
            for (let y = 0; y < rows; y++) {
                flowField[y] = [];
                for (let x = 0; x < cols; x++) {
                    flowField[y][x] = {
                        vx: 0,
                        vy: 0,
                        motion: 0,
                        recovery: 0
                    };
                }
            }
        }
        
        // Initialize particles
        function initializeParticles() {
            particles = [];
            const spacing = gridSize / settings.fluidDensity;
            
            for (let x = 0; x < window.innerWidth; x += spacing) {
                for (let y = 0; y < window.innerHeight; y += spacing) {
                    particles.push({
                        x: x + Math.random() * spacing,
                        y: y + Math.random() * spacing,
                        vx: 0,
                        vy: 0,
                        size: Math.random() * 3 + 2,
                        life: 1,
                        baseX: x,
                        baseY: y
                    });
                }
            }
        }
        
        // Initialize webcam
        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    status.textContent = 'Webcam active - Move to interact!';
                    setTimeout(() => status.style.display = 'none', 3000);
                    detectMotion();
                };
            } catch (err) {
                status.textContent = 'Webcam access denied';
                status.classList.add('error');
                console.error('Webcam error:', err);
            }
        }
        
        // Motion detection
        function detectMotion() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 640;
            tempCanvas.height = 480;
            
            function processFrame() {
                tempCtx.save();
                if (mirrored) {
                    tempCtx.scale(-1, 1);
                    tempCtx.drawImage(video, -tempCanvas.width, 0, tempCanvas.width, tempCanvas.height);
                } else {
                    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                }
                tempCtx.restore();
                
                const currentFrame = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                if (previousFrame) {
                    detectMotionDifference(previousFrame, currentFrame);
                }
                
                previousFrame = currentFrame;
                requestAnimationFrame(processFrame);
            }
            
            processFrame();
        }
        
        // Detect motion difference between frames
        function detectMotionDifference(prev, curr) {
            const sensitivity = settings.sensitivity;
            const scaleX = window.innerWidth / 640;
            const scaleY = window.innerHeight / 480;
            
            // Reset motion data
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (flowField[y][x].motion > 0) {
                        flowField[y][x].motion *= 0.95; // Decay motion
                    }
                    if (flowField[y][x].recovery > 0) {
                        flowField[y][x].recovery -= 0.016; // ~60fps, 2 seconds recovery
                    }
                }
            }
            
            // Detect motion in blocks
            for (let y = 0; y < 480; y += 10) {
                for (let x = 0; x < 640; x += 10) {
                    let diff = 0;
                    let vx = 0;
                    let vy = 0;
                    
                    for (let dy = 0; dy < 10; dy++) {
                        for (let dx = 0; dx < 10; dx++) {
                            const idx = ((y + dy) * 640 + (x + dx)) * 4;
                            
                            const dr = Math.abs(curr.data[idx] - prev.data[idx]);
                            const dg = Math.abs(curr.data[idx + 1] - prev.data[idx + 1]);
                            const db = Math.abs(curr.data[idx + 2] - prev.data[idx + 2]);
                            
                            diff += (dr + dg + db) / 3;
                            
                            // Simple motion vector estimation
                            if (dr + dg + db > sensitivity) {
                                vx += (curr.data[idx] - prev.data[idx]) / 255;
                                vy += (curr.data[idx + 1] - prev.data[idx + 1]) / 255;
                            }
                        }
                    }
                    
                    diff /= 100; // Average difference
                    
                    if (diff > sensitivity) {
                        const gridX = Math.floor(x * scaleX / gridSize);
                        const gridY = Math.floor(y * scaleY / gridSize);
                        
                        if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
                            flowField[gridY][gridX].motion = Math.min(diff / sensitivity, 1);
                            flowField[gridY][gridX].vx = vx * 10;
                            flowField[gridY][gridX].vy = vy * 10;
                            flowField[gridY][gridX].recovery = 2; // 2 seconds
                        }
                    }
                }
            }
        }
        
        // Update particles
        function updateParticles() {
            const speed = settings.flowSpeed;
            
            particles.forEach(p => {
                const gridX = Math.floor(p.x / gridSize);
                const gridY = Math.floor(p.y / gridSize);
                
                if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
                    const cell = flowField[gridY][gridX];
                    
                    if (cell.motion > 0.1) {
                        // Repel from motion
                        const dx = p.x - (gridX + 0.5) * gridSize;
                        const dy = p.y - (gridY + 0.5) * gridSize;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            const force = cell.motion * 50;
                            p.vx += (dx / dist) * force + cell.vx * 5;
                            p.vy += (dy / dist) * force + cell.vy * 5;
                        }
                        
                        p.life = Math.max(0, p.life - 0.05);
                    } else if (cell.recovery <= 0) {
                        // Return to base position
                        const dx = p.baseX - p.x;
                        const dy = p.baseY - p.y;
                        p.vx += dx * 0.01;
                        p.vy += dy * 0.01;
                        p.life = Math.min(1, p.life + 0.02);
                    }
                }
                
                // Add flow noise
                const noise = Math.sin(p.x * 0.01 + Date.now() * 0.001) * Math.cos(p.y * 0.01 + Date.now() * 0.0011);
                p.vx += noise * 0.5 * speed;
                p.vy += Math.cos(noise) * 0.5 * speed;
                
                // Apply velocity
                p.x += p.vx * speed;
                p.y += p.vy * speed;
                
                // Damping
                p.vx *= 0.95;
                p.vy *= 0.95;
                
                // Boundaries with wrapping
                if (p.x < 0) p.x = window.innerWidth;
                if (p.x > window.innerWidth) p.x = 0;
                if (p.y < 0) p.y = window.innerHeight;
                if (p.y > window.innerHeight) p.y = 0;
            });
        }
        
        // Render fluid
        function renderFluid() {
            fluidCtx.fillStyle = settings.backgroundColor;
            fluidCtx.fillRect(0, 0, fluidCanvas.width, fluidCanvas.height);
            
            // Create gradient effect
            const gradient = fluidCtx.createRadialGradient(
                fluidCanvas.width / 2, fluidCanvas.height / 2, 0,
                fluidCanvas.width / 2, fluidCanvas.height / 2, fluidCanvas.width / 2
            );
            
            const color = settings.fluidColor;
            gradient.addColorStop(0, color + '22');
            gradient.addColorStop(1, color + '00');
            
            fluidCtx.fillStyle = gradient;
            fluidCtx.fillRect(0, 0, fluidCanvas.width, fluidCanvas.height);
            
            // Draw particles
            particles.forEach(p => {
                if (p.life > 0.1) {
                    const alpha = p.life * 0.8;
                    fluidCtx.fillStyle = settings.fluidColor + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    fluidCtx.beginPath();
                    fluidCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    fluidCtx.fill();
                }
            });
            
            // Draw motion areas (debug visualization - optional)
            if (false) { // Set to true to see motion detection areas
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (flowField[y][x].motion > 0.1) {
                            fluidCtx.fillStyle = `rgba(255, 0, 0, ${flowField[y][x].motion * 0.3})`;
                            fluidCtx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        }
                    }
                }
            }
        }
        
        // Animation loop
        function animate() {
            updateParticles();
            renderFluid();
            requestAnimationFrame(animate);
        }
        
        // Control functions
        function toggleMirror() {
            mirrored = !mirrored;
            event.target.textContent = `Mirror: ${mirrored ? 'ON' : 'OFF'}`;
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function toggleUI() {
            uiHidden = !uiHidden;
            controls.classList.toggle('hidden', uiHidden);
            toggleBtn.classList.toggle('show', uiHidden);
            toggleBtn.textContent = uiHidden ? 'Show Controls' : 'Hide UI';
        }
        
        function resetSimulation() {
            initializeFlowField();
            initializeParticles();
        }
        
        // Event listeners
        document.getElementById('fluidColor').addEventListener('input', (e) => {
            settings.fluidColor = e.target.value;
        });
        
        document.getElementById('backgroundColor').addEventListener('input', (e) => {
            settings.backgroundColor = e.target.value;
        });
        
        document.getElementById('sensitivity').addEventListener('input', (e) => {
            settings.sensitivity = parseInt(e.target.value);
        });
        
        document.getElementById('fluidDensity').addEventListener('input', (e) => {
            settings.fluidDensity = parseInt(e.target.value);
            initializeParticles();
        });
        
        document.getElementById('flowSpeed').addEventListener('input', (e) => {
            settings.flowSpeed = parseFloat(e.target.value);
        });
        
        window.addEventListener('resize', resizeCanvases);
        
        // Initialize
        resizeCanvases();
        initWebcam();
        animate();
    </script>
</body>
</html>
